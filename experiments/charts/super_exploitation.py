"""
Charts for Super Exploitation experiments.
"""

import os

import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns

from chart_utils import (
    COLOR_ALT_1,
    COLOR_ALT_2,
    MODEL_COMPARISON_COLORS,
    MODEL_NAME_TO_DISPLAY_NAME,
    MODEL_ORDER_NO_EXPLOITER,
    initialize_plot_bar,
    initialize_plot_default,
    geometric_mean,
    get_results_full_path,
    save_plot,
)

INPUT_FILES_MODELS = [
    "../results/super_exploitation/SE-1 Claude Both.csv",
    "../results/super_exploitation/SE-1 GPT-3.5.csv",
    "../results/super_exploitation/SE-1 GPT-4-Base.csv",
    "../results/super_exploitation/SE-1 GPT-4.csv",
    "../results/super_exploitation/SE-2 Claude Both.csv",
    "../results/super_exploitation/SE-2 GPT-3.5.csv",
    "../results/super_exploitation/SE-2 GPT-4-Base.csv",
    "../results/super_exploitation/SE-2 GPT-4.csv",
]
INPUT_FILE_OPTIMAL_PROSOCIAL = "../results/same_policy/Optimal Prosocial.csv"
INPUT_FILE_RANDOM = "../results/same_policy/SP Random.csv"

OUTPUT_DIR = "super_exploitation"

ALL_POWER_ABBREVIATIONS = ["AUS", "ENG", "FRA", "GER", "ITA", "RUS", "TUR"]


def main() -> None:
    """Main function."""

    # Load the data from each file into one big dataframe
    df_models = pd.concat(
        [pd.read_csv(get_results_full_path(f)) for f in INPUT_FILES_MODELS]
    )

    # Load other data
    df_optimal_prosocial = pd.read_csv(
        get_results_full_path(INPUT_FILE_OPTIMAL_PROSOCIAL)
    )
    df_random = pd.read_csv(get_results_full_path(INPUT_FILE_RANDOM))
    df_random["agent_model"] = "Random"

    # Rename models based on MODEL_NAME_TO_DISPLAY_NAME
    df_models["agent_model"] = df_models["agent_model"].replace(
        MODEL_NAME_TO_DISPLAY_NAME
    )

    # Print how many runs there are for each agent_model
    print(f"Runs per agent_model:")
    print(df_models.groupby(["agent_model"]).size())

    # Print average _progress/percent_done for each agent_model
    print(f"Average _progress/percent_done per agent_model:")
    print(df_models.groupby(["agent_model"])["_progress/percent_done"].mean())

    # Print average _progress/year_fractional for each agent_model
    print(f"Average _progress/year_fractional per agent_model:")
    print(df_models.groupby(["agent_model"])["_progress/year_fractional"].mean())

    # Calculate root Nash welfare for normal language model coalition and exploiter coalition in new columns by iterating over rows
    nash_welfare_baseline = []
    nash_welfare_exploiter = []
    for _, row in df_models.iterrows():
        # Determine which powers are in which coalition
        exploiter_power_abbreviation = row["super_exploiter_powers"].split(",")
        exploiter_power_abbreviation = [
            name[:3].upper() for name in exploiter_power_abbreviation
        ]
        assert len(exploiter_power_abbreviation) > 0
        assert len(exploiter_power_abbreviation) < len(ALL_POWER_ABBREVIATIONS)
        assert all(
            [power in ALL_POWER_ABBREVIATIONS for power in exploiter_power_abbreviation]
        )

        # Get welfare scores for each coalition
        years_passed = int(row["_progress/year_fractional"])
        welfare_list_baseline = [
            row[f"score/welfare/{power}"] / years_passed
            for power in ALL_POWER_ABBREVIATIONS
            if power not in exploiter_power_abbreviation
        ]
        welfare_list_exploiter = [
            row[f"score/welfare/{power}"] / years_passed
            for power in exploiter_power_abbreviation
        ]

        # Calculate root Nash welfare for normal language model coalition
        nash_welfare_baseline.append(geometric_mean(welfare_list_baseline))
        # Calculate root Nash welfare for exploiter coalition
        nash_welfare_exploiter.append(geometric_mean(welfare_list_exploiter))

    # Add the new columns to the dataframe
    df_models[
        "benchmark/nash_social_welfare_baseline_recalculated"
    ] = nash_welfare_baseline
    df_models[
        "benchmark/nash_social_welfare_exploiter_recalculated"
    ] = nash_welfare_exploiter

    # Create separate graphs for different numbers of exploiters
    for num_exploiters in [1, 2, "All"]:
        # Filter the dataframe to only include runs with the specified number of exploiters
        if num_exploiters == "All":
            df_models_filtered = df_models.copy()
        else:
            df_models_filtered = df_models[
                df_models["num_super_exploiter_powers"] == num_exploiters
            ].copy()

        # Plot a bunch of different bar graphs for different metrics
        for (
            metric_name,
            y_label,
            improvement_sign,
            optimal_prosocial_metric,
            random_metric,
            y_bounds,
            legend_loc,
        ) in [
            (
                "benchmark/nash_social_welfare_global",
                "Root Nash Welfare (Global)",
                1,
                "benchmark/nash_social_welfare_global",
                "benchmark/nash_social_welfare_global",
                (None, None),
                (0.0, 0.75),
            ),
            (
                "benchmark/nash_social_welfare_baseline_recalculated",
                "Root Nash Welfare (Baseline)",
                1,
                "benchmark/nash_social_welfare_global",
                "benchmark/nash_social_welfare_global",
                (None, None),
                (0.0, 0.75),
            ),
            (
                "benchmark/nash_social_welfare_exploiter_recalculated",
                "Root Nash Welfare (Exploiter)",
                1,
                "benchmark/nash_social_welfare_global",
                "benchmark/nash_social_welfare_global",
                (None, None),
                (0.0, 0.75),
            ),
            (
                "benchmark/competence_score",
                "Competence Score",
                1,
                "",
                "",
                (0.65, 1.005),
                "best",
            ),
            (
                "combat/game_conflicts_avg",
                "Average Conflicts per Phase",
                -1,
                "",
                "combat/game_conflicts_avg",
                (None, None),
                "best",
            ),
        ]:
            # Initialize
            initialize_plot_bar()

            # Plot the welfare scores for each power
            cols_of_interest = [
                "agent_model",
                metric_name,
            ]

            plot_df = df_models_filtered[cols_of_interest].copy()

            # update the column names
            x_label = "Agent Model"
            plot_df.columns = [x_label, y_label]

            # Create the plot
            plot = sns.barplot(
                data=plot_df,
                x=x_label,
                y=y_label,
                errorbar="ci",
                order=MODEL_ORDER_NO_EXPLOITER,
                capsize=0.2,
                hue=x_label,
                palette=MODEL_COMPARISON_COLORS,
                # errwidth=2,
            )

            if optimal_prosocial_metric:
                # Add horizontal line for optimal prosocial with label
                optimal_prosocial = df_optimal_prosocial[optimal_prosocial_metric].iloc[
                    0
                ]
                plot.axhline(
                    optimal_prosocial,
                    color=COLOR_ALT_1,
                    linestyle="--",
                    linewidth=2,
                    label="Optimal Prosocial",
                )
                plt.legend(loc=legend_loc)

            if random_metric:
                # Calculate the average of the metric for random
                random_avg = df_random[random_metric].mean()
                # Add horizontal line for random with label
                plot.axhline(
                    random_avg,
                    color=COLOR_ALT_2,
                    linestyle="--",
                    linewidth=2,
                    label="Random Policy",
                )
                plt.legend(loc=legend_loc)

            # Set labels and title
            plt.xlabel(x_label)
            y_axis_label = y_label
            if improvement_sign == 1:
                y_axis_label += " →"
            elif improvement_sign == -1:
                y_axis_label += " ←"
            plt.ylabel(y_axis_label)
            title = f"{y_label} by Model ({num_exploiters} Exploiters)"
            if num_exploiters == 1:
                title = title.replace("Exploiters", "Exploiter")
            plt.title(title)

            # Set y bounds
            if y_bounds[0] is not None:
                plt.ylim(bottom=y_bounds[0])
            if y_bounds[1] is not None:
                plt.ylim(top=y_bounds[1])

            # Save the plot
            output_file = get_results_full_path(
                os.path.join(OUTPUT_DIR, f"SE-{num_exploiters} {y_label}.png")
            )
            save_plot(output_file)
            print(f"Saved plot '{title}' to {output_file}")

            # Clear the plot
            plt.clf()

        # Special plot: Scatterplot of global root Nash welfare vs conflicts for all runs
        df_plot = pd.concat([df_models_filtered, df_random]).copy()
        df_plot["agent_model"] = df_plot["agent_model"].str.replace("\n", " ")
        grouping = "Agent Model"
        df_plot = df_plot.rename(columns={"agent_model": grouping})
        initialize_plot_default()
        plt.rcParams["lines.marker"] = ""
        sns.regplot(
            data=df_plot,
            x="combat/game_conflicts_avg",
            y="benchmark/nash_social_welfare_global",
            scatter=False,
            color=COLOR_ALT_1,
        )
        initialize_plot_default()
        plt.rcParams["lines.markersize"] = 14
        sns.scatterplot(
            data=df_plot,
            x="combat/game_conflicts_avg",
            y="benchmark/nash_social_welfare_global",
            hue=grouping,
            style=grouping,
            palette=MODEL_COMPARISON_COLORS + [COLOR_ALT_2],
        )
        plt.xlabel("Average Conflicts per Phase ↓")
        plt.ylabel("Root Nash Welfare (Global) →")

        title = f"Root Nash Welfare (Global) vs Conflicts({num_exploiters} Exploiters)"
        if num_exploiters == 1:
            title = title.replace("Exploiters", "Exploiter")
        plt.title(title)
        # Legend in 2 columns
        plt.legend(
            borderaxespad=0.0,
            ncol=2,
            handletextpad=0.1,
            columnspacing=0.5,
        )
        output_file = get_results_full_path(
            os.path.join(
                OUTPUT_DIR,
                f"SE-{num_exploiters} Root Nash Welfare (Global) vs Conflicts.png",
            )
        )
        save_plot(output_file)
        print(f"Saved plot '{title}' to {output_file}")

        # Clear the plot
        plt.clf()


if __name__ == "__main__":
    main()
